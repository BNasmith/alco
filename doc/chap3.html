<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (ALCO) - Chapter 3: Simple Euclidean Jordan Algebras</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X7E13C2AE7DEAF62D" name="X7E13C2AE7DEAF62D"></a></p>
<div class="ChapSects"><a href="chap3.html#X7E13C2AE7DEAF62D">3 <span class="Heading">Simple Euclidean Jordan Algebras</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X802D4E3380BC3177">3.1 <span class="Heading">Filters and Basic Attributes</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X878107A77FBFD00A">3.1-1 <span class="Heading">Jordan Filters</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D20807E8513CEE8">3.1-2 <span class="Heading">Jordan Rank</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CFD4EB480976FF8">3.1-3 <span class="Heading">Jordan Degree</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80051D4E7B64E102">3.1-4 Trace</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X844D03667EC7C372">3.1-5 Determinant</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83B5D76B87AEF802">3.1-6 Norm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85D508B5853906E5">3.1-7 GenericMinimalPolynomial</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7FBD095A7B884F7F">3.2 <span class="Heading">Jordan Algebra Constructions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7852050A81DEB9F4">3.2-1 SimpleEuclideanJordanAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C6713C8178A69F">3.2-2 JordanSpinFactor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X859F001D7CB6CBD8">3.2-3 HermitianSimpleJordanAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X800B48C383196E06">3.2-4 JordanHomotope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7B9397277AF7F920">3.3 <span class="Heading">The Albert Algebra</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A6AFFE07994B4A9">3.3-1 AlbertAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X860036647BB9325E">3.3-2 AlbertVectorToHermitianMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8385802B7AE842E6">3.3-3 HermitianMatrixToAlbertVector</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7F03850D819127E2">3.4 <span class="Heading">The Quadratic Representation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79DF7566833EA9F9">3.4-1 JordanQuadraticOperator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B5ABEA7816F6258">3.4-2 JordanTripleSystem</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7EA1D48F853C02F1">3.5 <span class="Heading">Additional Tools and Properties</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C236EB080D05CD4">3.5-1 HermitianJordanAlgebraBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X853480DC7F9B0BD7">3.5-2 JordanMatrixBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D167A057F3CB029">3.5-3 HermitianMatrixToJordanVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B6084887C1C5AF1">3.5-4 JordanAlgebraGramMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X806F76C07B315DE4">3.5-5 JordanAdjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C82B2EB78CF9C17">3.5-6 IsPositiveDefinite</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Simple Euclidean Jordan Algebras</span></h3>

<p>A Jordan algebra is a commutative yet nonassociative algebra with product <span class="Math">\circ</span> that satisfies the Jordan identity <span class="Math">x\circ(x^2 \circ y) = x^2 \circ (x\circ y)</span>. Given an associative algebra, we can define a Jordan algebra on the same elements using the product <span class="Math">x \circ y = (xy + yx)/2</span>. A Jordan algebra <span class="Math">V</span> is <em>Euclidean</em> when there exists an inner product <span class="Math">(x,y)</span> on <span class="Math">V</span> that satisfies <span class="Math">(x\circ y, z) = (y, x\circ z)</span> for all <span class="Math">x,y,z</span> in <span class="Math">V</span> <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, p. 42]</a>. Euclidean Jordan algebras are in one-to-one correspondence with structures known as symmetric cones, and any Euclidean Jordan algebra is the direct sum of simple Euclidean Jordan algebras <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, chap. 3]</a>.</p>

<p>The simple Euclidean Jordan algebras, in turn, are classified by rank and degree into four families and one exception <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, chap. 5]</a>. The first family consists of rank 2 algebras with degree any positive integer. The remaining three families consist Jordan algebras with degree 1, 2, or 4 with rank a positive integer greater than 2. The exceptional algebra has rank 3 and degree 8.</p>

<p>The <strong class="pkg">ALCO</strong> package provides a number of tools to construct and manipulate simple Euclidean Jordan algebras (described well in <a href="chapBib.html#biBfaraut_analysis_1994">[FK94]</a>), including their homotope and isotopes algebras (defined in <a href="chapBib.html#biBmccrimmon_taste_2004">[McC04, p. 86]</a>). Among other applications, these tools can reproduce many of the examples found in <a href="chapBib.html#biBelkies_exceptional_1996">[EG96]</a> and <a href="chapBib.html#biBelkies_cubic_2001">[EG01]</a>.</p>

<p><a id="X802D4E3380BC3177" name="X802D4E3380BC3177"></a></p>

<h4>3.1 <span class="Heading">Filters and Basic Attributes</span></h4>

<p><a id="X878107A77FBFD00A" name="X878107A77FBFD00A"></a></p>

<h5>3.1-1 <span class="Heading">Jordan Filters</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsJordanAlgebra</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsJordanAlgebraObj</code></td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>These filters determine whether an element is a Jordan algebra (<code class="code">IsJordanAlgebra</code>) or is an element in a Jordan algebra (<code class="code">IsJordanAlgebraObj</code>).</p>

<p><a id="X7D20807E8513CEE8" name="X7D20807E8513CEE8"></a></p>

<h5>3.1-2 <span class="Heading">Jordan Rank</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanRank</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Rank</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The rank of a Jordan algeba is the size of a maximal set of mutually orthogonal primitive idempotents in the algebra. The rank and degree are used to classify the simple Euclidean Jordan algebras. This method returns the rank of <var class="Arg">x</var> when <code class="code">IsJordanAlgebra(<var class="Arg">x</var>)</code> or the rank of the Jordan algebra containing <var class="Arg">x</var> (computed as <code class="code">FamilyObj(x)!.fullSCAlgebra</code>) when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code>. The method <code class="code">Rank(<var class="Arg">x</var>)</code> returns <code class="code">JordanRank(<var class="Arg">x</var>)</code> when <var class="Arg">x</var> satisfies either <code class="code">IsJordanAlgebra</code> or <code class="code">IsJordanAlgebraObj</code>.</p>

<p><a id="X7CFD4EB480976FF8" name="X7CFD4EB480976FF8"></a></p>

<h5>3.1-3 <span class="Heading">Jordan Degree</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanDegree</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Degree</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>The degree of a Jordan algebra is the dimension of the off-diagonal entries in a Pierce decomposition of the Jordan algebra. For example, a Jordan algebra of quaternion hermitian matrices has degree 4. This method returns the degree of <var class="Arg">x</var> when <code class="code">IsJordanAlgebra(<var class="Arg">x</var>)</code> or the degree of the Jordan algebra containing <var class="Arg">x</var> (computed as <code class="code">FamilyObj(x)!.fullSCAlgebra</code>) when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code>. The method <code class="code">Degree(<var class="Arg">x</var>)</code> returns <code class="code">JordanDegree(<var class="Arg">x</var>)</code> when <var class="Arg">x</var> satisfies either <code class="code">IsJordanAlgebra</code> or <code class="code">IsJordanAlgebraObj</code>.</p>

<p>Each vector in a simple Euclidean Jordan algebra can be written as a ℝ-linear combination of mutually orthogonal primitive idempotents. This is called the <em>spectral decomposition</em> of a Jordan algebra element. The coefficients in the decomposition are the <em>eigenvalues</em> of the element. The Jordan trace and determinant, described below, are respectively the sum and product of these eigenvalues with multiplicities included <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, p. 44]</a>.</p>

<p><a id="X80051D4E7B64E102" name="X80051D4E7B64E102"></a></p>

<h5>3.1-4 Trace</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Trace</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns the Jordan trace of <var class="Arg">x</var> when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code>. The trace of a Jordan algebra element is the sum of the eigenvalues of that element (with multiplicies included).</p>

<p><a id="X844D03667EC7C372" name="X844D03667EC7C372"></a></p>

<h5>3.1-5 Determinant</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Determinant</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns the Jordan determinant of <var class="Arg">x</var> when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code>. The determinant of a Jordan algebra element is the product of the eigenvalues of that element (with multiplicies included).</p>

<p><a id="X83B5D76B87AEF802" name="X83B5D76B87AEF802"></a></p>

<h5>3.1-6 Norm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Norm</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Returns the Jordan norm of <var class="Arg">x</var> when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code>. The Jordan norm has the value <code class="code">Trace(<var class="Arg">x</var>^2)/2</code>.</p>

<p><a id="X85D508B5853906E5" name="X85D508B5853906E5"></a></p>

<h5>3.1-7 GenericMinimalPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GenericMinimalPolynomial</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns the generic minimal polynomial of <var class="Arg">x</var> when <code class="code">IsJordanAlgebraObj(<var class="Arg">x</var>)</code> as defined in <a href="chapBib.html#biBfaraut_analysis_2000">[FKK+00, p. 478]</a> (see also <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, pp. 27-31]</a>). The output is given as a list of polynomial coefficients. Note that the generic minimal polynomial is a monic polynomial of degree equal to the rank of the Jordan algebra. The trace and determinant of a Jordan algebra element are, to within a sign, given by the coefficients of the second highest degree term and the constant term.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := AlbertAlgebra(Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Sum(Basis(J){[4,5,6,25,26,27]});</span>
i4+i5+i6+ei+ej+ek
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[JordanRank(J), JordanDegree(J)];</span>
[ 3, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[JordanRank(x), JordanDegree(x)];</span>
[ 3, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := GenericMinimalPolynomial(x);</span>
[ 2, 0, -3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Trace(x);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Determinant(x);</span>
-2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Norm(x);</span>
9/2</pre></div>

<p><a id="X7FBD095A7B884F7F" name="X7FBD095A7B884F7F"></a></p>

<h4>3.2 <span class="Heading">Jordan Algebra Constructions</span></h4>

<p>The classification of simple Euclidean Jordan algebras is described in <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, chap. 5]</a>. A simple Euclidean Jordan algebra can be constructed in the following two ways. A rank <span class="Math">2</span> algebra can be constructed from a positive definite Gram matrix in the manner described in <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, p. 25]</a>. A degree <span class="Math">1</span>, <span class="Math">2</span>, <span class="Math">4</span>, or <span class="Math">8</span> algebra can be constructed using Hermitian matrices over a composition algebra of dimension equal to the degree with the product <span class="Math">(xy+yx)/2</span>. In certain cases both constructions are possible. The <strong class="pkg">ALCO</strong> package provides tools to use both constructions to create simple Euclidean Jordan algebras with elements that satisfy <code class="code">IsSCAlgebraObj</code>.</p>

<p><a id="X7852050A81DEB9F4" name="X7852050A81DEB9F4"></a></p>

<h5>3.2-1 SimpleEuclideanJordanAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleEuclideanJordanAlgebra</code>( <var class="Arg">rho</var>, <var class="Arg">d</var>[, <var class="Arg">args</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a simple Euclidean Jordan algebra over ℚ. The construction used depends on the arguments given in the following manner.</p>

<p>For Jordan algebras of rank <var class="Arg">rho</var> equal to <span class="Math">2</span>, the <code class="func">JordanSpinFactor</code> (<a href="chap3.html#X86C6713C8178A69F"><span class="RefLink">3.2-2</span></a>) construction is used. If optional <var class="Arg">args</var> is empty then the result is <code class="code">JordanSpinFactor(IdentityMat(<var class="Arg">d</var>+1))</code>. If optional <var class="Arg">args</var> is a symmetric matrix of dimension <var class="Arg">d</var>+1, then <code class="code">JordanSpinFactor(args)</code> is used. If neither of these rank 2 cases apply, and <var class="Arg">d</var> is equal to 1,2,4, or 8, and if <var class="Arg">args</var> is a composition algebra basis, then <code class="code">HermitianSimpleJordanAlgebra(<var class="Arg">rho</var>, <var class="Arg">args</var>)</code> is used.</p>

<p>In the cases where rank <var class="Arg">rho</var> is greater than <span class="Math">2</span>, we must have <var class="Arg">d</var> equal to one of <span class="Math">1</span>, <span class="Math">2</span>, <span class="Math">4</span>, or <span class="Math">8</span>. Note that <var class="Arg">d</var> equals <span class="Math">8</span> is only permitted when <var class="Arg">rho</var> equals <span class="Math">3</span>. When optional <var class="Arg">args</var> is a composition algebra basis of dimension <var class="Arg">d</var>, <code class="code">HermitianSimpleJordanAlgebra(<var class="Arg">rho</var>, <var class="Arg">args</var>)</code> is used. Otherwise, when optional <var class="Arg">args</var> is empty, this function uses <code class="code">HermitianSimpleJordanAlgebra(<var class="Arg">rho</var>, <var class="Arg">B</var>)</code> for <var class="Arg">B</var> either <code class="code">CanonicalBasis(Rationals)</code>, <code class="code">Basis(CF(4), [1, E(4)])</code>, <code class="code">CanonicalBasis(QuaternionAlgebra(Rationals))</code>, or <code class="code">CanonicalBasis(OctonionAlgebra(Rationals))</code>.</p>

<p>Note that (in contrast to <code class="func">AlbertAlgebra</code> (<a href="chap3.html#X7A6AFFE07994B4A9"><span class="RefLink">3.3-1</span></a>)) the Hermitian Jordan algebras constructed using <code class="code">SimpleEuclideanJordanAlgebra</code> uses the upper triangular entries of the Hermitian matrices define the basis vectors.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := SimpleEuclideanJordanAlgebra(3,8);</span>
&lt;algebra-with-one of dimension 27 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Derivations(Basis(J));; SemiSimpleType(last);</span>
"F4"</pre></div>

<p><a id="X86C6713C8178A69F" name="X86C6713C8178A69F"></a></p>

<h5>3.2-2 JordanSpinFactor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanSpinFactor</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a Jordan spin factor algebra when <var class="Arg">G</var> is a positive definite Gram matrix. This is the Jordan algebra of rank 2 constructed from a symmetric bilinear form, as described in <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, p. 25]</a>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := JordanSpinFactor(IdentityMat(8));</span>
&lt;algebra-with-one of dimension 9 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One(J);</span>
v.1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[JordanRank(J), JordanDegree(J)];</span>
[ 2, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Derivations(Basis(J));</span>
&lt;Lie algebra of dimension 28 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SemiSimpleType(last);</span>
"D4"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := Sum(Basis(J){[4,5,6,7]});</span>
v.4+v.5+v.6+v.7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[Trace(x), Determinant(x)];</span>
[ 0, -4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := GenericMinimalPolynomial(x);</span>
[ -4, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ValuePol(p,x);</span>
0*v.1</pre></div>

<p><a id="X859F001D7CB6CBD8" name="X859F001D7CB6CBD8"></a></p>

<h5>3.2-3 HermitianSimpleJordanAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianSimpleJordanAlgebra</code>( <var class="Arg">r</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a simple Euclidean Jordan algebra of rank <var class="Arg">r</var> with the basis for the off-diagonal components defined using composition algebra basis <var class="Arg">B</var>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := HermitianSimpleJordanAlgebra(3,QuaternionD4Basis);</span>
&lt;algebra-with-one of dimension 15 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[JordanRank(J), JordanDegree(J)];</span>
[ 3, 4 ]</pre></div>

<p><a id="X800B48C383196E06" name="X800B48C383196E06"></a></p>

<h5>3.2-4 JordanHomotope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanHomotope</code>( <var class="Arg">J</var>, <var class="Arg">u</var>[, <var class="Arg">s</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For <var class="Arg">J</var> a Jordan algebra satisfying <code class="code">IsJordanAlgebra(<var class="Arg">J</var> )</code>, and for <var class="Arg">u</var> a vector in <var class="Arg">J</var>, this function returns the corresponding <var class="Arg">u</var>-homotope algebra with the product of <span class="Math">x</span> and <span class="Math">y</span> defined as <span class="Math">x(uy)+(xu)y - u(xy)</span>. The <var class="Arg">u</var>-homotope algebra also belongs to the filter <code class="code">IsJordanAlgebra</code>.</p>

<p>Of note, if <var class="Arg">u</var> is invertible in <var class="Arg">J</var> then the corresponding <var class="Arg">u</var>-homotope algebra is called a <var class="Arg">u</var>-isotope. The optional argument <var class="Arg">s</var> is a string that determines the labels of the canonical basis vectors in the new algebra. The main definitions and properties of Jordan homotopes and isotopes are given in <a href="chapBib.html#biBmccrimmon_taste_2004">[McC04, pp.82-86]</a>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := SimpleEuclideanJordanAlgebra(2,7);</span>
&lt;algebra-with-one of dimension 9 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := Sum(Basis(J){[1,2,7,8]});</span>
v.1+v.2+v.7+v.8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Inverse(u);</span>
(-1/2)*v.1+(1/2)*v.2+(1/2)*v.7+(1/2)*v.8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GenericMinimalPolynomial(u);</span>
[ -2, -2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := JordanHomotope(J, u, "w.");</span>
&lt;algebra-with-one of dimension 9 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">One(H);</span>
(-1/2)*w.1+(1/2)*w.2+(1/2)*w.7+(1/2)*w.8</pre></div>

<p><a id="X7B9397277AF7F920" name="X7B9397277AF7F920"></a></p>

<h4>3.3 <span class="Heading">The Albert Algebra</span></h4>

<p>The exceptional simple Euclidean Jordan algebra, or Albert algebra, may be constructed using <code class="func">SimpleEuclideanJordanAlgebra</code> (<a href="chap3.html#X7852050A81DEB9F4"><span class="RefLink">3.2-1</span></a>) with rank 3 and degree 8. However, that construction uses the upper triangular entries of the Hermitian matrices define the basis vectors (i.e., the <code class="code">[1][2], [2][3], [1][3]</code> entries). Much of the literature on the Albert algebra instead uses the <code class="code">[1][2], [2][3], [3][1]</code> entries of the Hermitian matrices to define the basis vectors (see for example <a href="chapBib.html#biBwilson_finite_2009">[Wil09a, pp. 147-148]</a>). The <strong class="pkg">ALCO</strong> package provides a specific construction of the Albert algebra that uses this convention for defining basis vectors, described below.</p>

<p><a id="X7A6AFFE07994B4A9" name="X7A6AFFE07994B4A9"></a></p>

<h5>3.3-1 AlbertAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AlbertAlgebra</code>( <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For <var class="Arg">F</var> a field, this function returns an Albert algebra over <var class="Arg">F</var>. For <code class="code"><var class="Arg">F</var> = Rationals</code>, this algebra is isomorphic to <code class="code">HermitianSimpleJordanAlgebra(3,8,Basis(Oct))</code> but in a basis that is more convenient for reproducing certain calculations in the literature. Specifically, while <code class="code">HermitianSimpleJordanAlgebra(3,8,Basis(Oct))</code> uses the upper-triangular elements of a Hermitian matrix as representative, <code class="code">AlbertAlgebra(<var class="Arg">F</var>)</code> uses the <code class="code">[1][2], [2][3], [3][1]</code> entries as representative. These are respectively labeled using <code class="code">k,i,j</code>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := AlbertAlgebra(Rationals);</span>
&lt;algebra-with-one of dimension 27 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := Basis(A){[1..8]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j := Basis(A){[9..16]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := Basis(A){[17..24]};; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := Basis(A){[25..27]};;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(i); Display(j); Display(k); Display(e);</span>
[ i1, i2, i3, i4, i5, i6, i7, i8 ]
[ j1, j2, j3, j4, j5, j6, j7, j8 ]
[ k1, k2, k3, k4, k5, k6, k7, k8 ]
[ ei, ej, ek ]</pre></div>

<p><a id="X860036647BB9325E" name="X860036647BB9325E"></a></p>

<h5>3.3-2 AlbertVectorToHermitianMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AlbertVectorToHermitianMatrix</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For an element <var class="Arg">x</var> in <code class="code">AlbertAlgebra(<var class="Arg">Rationals</var>)</code>, this function returns the corresponding 3 x 3 Hermitian matrix with octonion entries in <code class="code">OctonionAlgebra(<var class="Arg">Rationals</var>)</code>.</p>

<p><a id="X8385802B7AE842E6" name="X8385802B7AE842E6"></a></p>

<h5>3.3-3 HermitianMatrixToAlbertVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianMatrixToAlbertVector</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For 3 x 3 Hermitian matrix with elements in <code class="code">OctonionAlgebra(<var class="Arg">Rationals</var>)</code>, this function returns the corresponding vector in in <code class="code">AlbertAlgebra(<var class="Arg">Rationals</var>)</code>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j := Basis(AlbertAlgebra(Rationals)){[9..16]};</span>
[ j1, j2, j3, j4, j5, j6, j7, j8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := AlbertVectorToHermitianMatrix(j[3]);; Display(mat);</span>
[ [     0*e1,     0*e1,  (-1)*e3 ],
  [     0*e1,     0*e1,     0*e1 ],
  [       e3,     0*e1,     0*e1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HermitianMatrixToAlbertVector(mat);</span>
j3</pre></div>

<p><a id="X7F03850D819127E2" name="X7F03850D819127E2"></a></p>

<h4>3.4 <span class="Heading">The Quadratic Representation</span></h4>

<p>Many important features of simple Euclidean Jordan algebra and their isotopes are related to the quadratic representation. This aspect of Jordan algebras is described well in <a href="chapBib.html#biBmccrimmon_taste_2004">[McC04, pp.82-86]</a> and <a href="chapBib.html#biBfaraut_analysis_1994">[FK94, pp. 32-38]</a>. The following methods allow for the construction of Jordan quadratic maps and the standard triple product on a Jordan algebra.</p>

<p><a id="X79DF7566833EA9F9" name="X79DF7566833EA9F9"></a></p>

<h5>3.4-1 JordanQuadraticOperator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanQuadraticOperator</code>( <var class="Arg">x</var>[, <var class="Arg">y</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For <var class="Arg">x</var> and <var class="Arg">y</var> Jordan algebra elements, satisfying <code class="code">IsJordanAlgebraObj</code> this operation applies two methods. In the case of <code class="code">JordanQuadraticOperator(<var class="Arg">x</var>, y)</code>, this operation returns <code class="code">2*x*(x*y) - (x^2)*y</code>. In the case of <code class="code">JordanQuadraticOperator(x)</code>, this operation returns the matrix representing the quadratic map in the canonical basis of the Jordan algebra <var class="Arg">J</var> containing <var class="Arg">x</var>. For <code class="code">L(x)</code> the matrix <code class="code">AdjointMatrix(CanonicalBasis(J), x)</code>, the operation <code class="code">JordanQuadraticOperator(<var class="Arg">x</var>)</code> returns the matrix <code class="code">2 L(x)^2 - L(x^2)</code>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := JordanSpinFactor(IdentityMat(3));</span>
&lt;algebra-with-one of dimension 4 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := [-1,4/3,-1,1]*Basis(J);</span>
(-1)*v.1+(4/3)*v.2+(-1)*v.3+v.4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y := [-1, -1/2, 2, -1/2]*Basis(J);</span>
(-1)*v.1+(-1/2)*v.2+(2)*v.3+(-1/2)*v.4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JordanQuadraticOperator(x,y);</span>
(14/9)*v.1+(-79/18)*v.2+(-11/9)*v.3+(-53/18)*v.4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JordanQuadraticOperator(x);; Display(last);</span>
[ [  43/9,  -8/3,     2,    -2 ],
  [  -8/3,   7/9,  -8/3,   8/3 ],
  [     2,  -8/3,  -7/9,    -2 ],
  [    -2,   8/3,    -2,  -7/9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LinearCombination(Basis(J), JordanQuadraticOperator(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">*ExtRepOfObj(y)) = JordanQuadraticOperator(x,y);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtRepOfObj(JordanQuadraticOperator(x,y)) = </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">JordanQuadraticOperator(x)*ExtRepOfObj(y);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JordanQuadraticOperator(2*x) = 4*JordanQuadraticOperator(x);</span>
true</pre></div>

<p><a id="X7B5ABEA7816F6258" name="X7B5ABEA7816F6258"></a></p>

<h5>3.4-2 JordanTripleSystem</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanTripleSystem</code>( <var class="Arg">x</var>, <var class="Arg">y</var>, <var class="Arg">z</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>For Jordan algebra elements <var class="Arg">x</var>, <var class="Arg">y</var>, <var class="Arg">z</var> satisfying <code class="code">IsJordanAlgebraObj</code>, the operation <code class="code">JordanTripleSystem(<var class="Arg">x</var>,<var class="Arg">y</var>,<var class="Arg">z</var>)</code> returns the Jordan triple product defined in terms of the Jordan product as <code class="code"><var class="Arg">x</var>*(<var class="Arg">y</var>*<var class="Arg">z</var>) + (<var class="Arg">x</var>*<var class="Arg">y</var>)*<var class="Arg">z</var> - <var class="Arg">y</var>*(<var class="Arg">x</var>*<var class="Arg">z</var>)</code>. Equivalently, <code class="code">2*JordanTripleSystem(<var class="Arg">x</var>,<var class="Arg">y</var>,<var class="Arg">z</var>)</code> is equal to <code class="code">JordanQuadraticOperator(x+z, y) - JordanQuadraticOperator(x, y) - JordanQuadraticOperator(z, y)</code>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := AlbertAlgebra(Rationals);</span>
&lt;algebra-with-one of dimension 27 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := Basis(J){[1..8]};</span>
[ i1, i2, i3, i4, i5, i6, i7, i8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">j := Basis(J){[9..16]};</span>
[ j1, j2, j3, j4, j5, j6, j7, j8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := Basis(J){[17..24]};</span>
[ k1, k2, k3, k4, k5, k6, k7, k8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := Basis(J){[25..27]};</span>
[ ei, ej, ek ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(i, x -&gt; JordanTripleSystem(i[1],i[1],x));</span>
[ i1, i2, i3, i4, i5, i6, i7, i8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(j, x -&gt; 2*JordanTripleSystem(i[1],i[1],x));</span>
[ j1, j2, j3, j4, j5, j6, j7, j8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(k, x -&gt; 2*JordanTripleSystem(i[1],i[1],x));</span>
[ k1, k2, k3, k4, k5, k6, k7, k8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(e, x -&gt; JordanTripleSystem(i[1],i[1],x));</span>
[ 0*i1, ej, ek ]</pre></div>

<p><a id="X7EA1D48F853C02F1" name="X7EA1D48F853C02F1"></a></p>

<h4>3.5 <span class="Heading">Additional Tools and Properties</span></h4>

<p><a id="X7C236EB080D05CD4" name="X7C236EB080D05CD4"></a></p>

<h5>3.5-1 HermitianJordanAlgebraBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianJordanAlgebraBasis</code>( <var class="Arg">r</var>, <var class="Arg">B</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns a set of Hermitian matrices to serve as a basis for the Jordan algebra of rank <var class="Arg">r</var> and degree given by the cardinality of composition algebra basis <var class="Arg">B</var>. The elements spanning each off-diagonal components are determined by basis <var class="Arg">B</var>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := QuaternionAlgebra(Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for x in HermitianJordanAlgebraBasis(2, Basis(H)) do Display(x); od;</span>
[ [    e,  0*e ],
  [  0*e,  0*e ] ]
[ [  0*e,  0*e ],
  [  0*e,    e ] ]
[ [  0*e,    e ],
  [    e,  0*e ] ]
[ [     0*e,       i ],
  [  (-1)*i,     0*e ] ]
[ [     0*e,       j ],
  [  (-1)*j,     0*e ] ]
[ [     0*e,       k ],
  [  (-1)*k,     0*e ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsList(Basis(H));</span>
[ e, i, j, k ]</pre></div>

<p><a id="X853480DC7F9B0BD7" name="X853480DC7F9B0BD7"></a></p>

<h5>3.5-2 JordanMatrixBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanMatrixBasis</code>( <var class="Arg">J</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>If <code class="code">IsJordanAlgebra( <var class="Arg">J</var> )</code> and <var class="Arg">J</var> has been constructed using <code class="func">HermitianSimpleJordanAlgebra</code> (<a href="chap3.html#X859F001D7CB6CBD8"><span class="RefLink">3.2-3</span></a>), then the set of matrices corresponding to <code class="code">CanonicalBasis( <var class="Arg">J</var> )</code> can be obtained using <code class="code">JordanMatrixBasis( <var class="Arg">J</var> )</code>.</p>

<p><a id="X7D167A057F3CB029" name="X7D167A057F3CB029"></a></p>

<h5>3.5-3 HermitianMatrixToJordanVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HermitianMatrixToJordanVector</code>( <var class="Arg">mat</var>, <var class="Arg">J</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Converts matrix <var class="Arg">mat</var> into an element of Jordan algebra <var class="Arg">J</var>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := QuaternionAlgebra(Rationals);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := HermitianSimpleJordanAlgebra(2,Basis(H));</span>
&lt;algebra-with-one of dimension 6 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsList(CanonicalBasis(J));</span>
[ v.1, v.2, v.3, v.4, v.5, v.6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">JordanMatrixBasis(J);; for x in last do Display(x); od;</span>
[ [    e,  0*e ],
  [  0*e,  0*e ] ]
[ [  0*e,  0*e ],
  [  0*e,    e ] ]
[ [  0*e,    e ],
  [    e,  0*e ] ]
[ [     0*e,       i ],
  [  (-1)*i,     0*e ] ]
[ [     0*e,       j ],
  [  (-1)*j,     0*e ] ]
[ [     0*e,       k ],
  [  (-1)*k,     0*e ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(JordanMatrixBasis(J), x -&gt; HermitianMatrixToJordanVector(x, J));</span>
[ v.1, v.2, v.3, v.4, v.5, v.6 ]</pre></div>

<p><a id="X7B6084887C1C5AF1" name="X7B6084887C1C5AF1"></a></p>

<h5>3.5-4 JordanAlgebraGramMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanAlgebraGramMatrix</code>( <var class="Arg">J</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>For <code class="code">IsJordanAlgebra( <var class="Arg">J</var> )</code>, returns the Gram matrix on <code class="code">CanonicalBasis( <var class="Arg">J</var> )</code> using inner product <code class="code">Trace(x*y)</code>.</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">J := HermitianSimpleJordanAlgebra(2,OctonionE8Basis);</span>
&lt;algebra-with-one of dimension 10 over Rationals&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(Basis(J), x -&gt; List(Basis(J), y -&gt; Trace(x*y))) = </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">JordanAlgebraGramMatrix(J);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DiagonalOfMat(JordanAlgebraGramMatrix(J));</span>
[ 1, 1, 2, 2, 2, 2, 2, 2, 2, 2 ]</pre></div>

<p><a id="X806F76C07B315DE4" name="X806F76C07B315DE4"></a></p>

<h5>3.5-5 JordanAdjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; JordanAdjugate</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>For <code class="code">IsJordanAlgebraObj( <var class="Arg">x</var> )</code>, returns the adjugate of <var class="Arg">x</var>, which satisfies <code class="code">x*JordanAdjugate(<var class="Arg">x</var>) = One(<var class="Arg">x</var>)*Determinant(<var class="Arg">x</var>)</code>. When <code class="code">Determinant(<var class="Arg">x</var>)</code> is non-zero, <code class="code">JordanAdjugate(<var class="Arg">x</var>)</code> is proportional to <code class="code">Inverse(<var class="Arg">x</var>)</code>.</p>

<p><a id="X7C82B2EB78CF9C17" name="X7C82B2EB78CF9C17"></a></p>

<h5>3.5-6 IsPositiveDefinite</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPositiveDefinite</code>( <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>For <code class="code">IsJordanAlgebraObj( <var class="Arg">x</var> )</code>, returns <code class="code">true</code> when <var class="Arg">x</var> is positive definite and <code class="code">false</code> otherwise. This filter uses <code class="func">GenericMinimalPolynomial</code> (<a href="chap3.html#X85D508B5853906E5"><span class="RefLink">3.1-7</span></a>) to determine whether <var class="Arg">x</var> is positive definite.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
