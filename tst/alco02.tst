# ALCO, chapter 2
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("alco02.tst");

# doc/ALCO.xml:111-125
gap> O := OctonionAlgebra(Rationals); e := Basis(O);;
<algebra-with-one of dimension 8 over Rationals>
gap> LeftActingDomain(O);
Rationals
gap> AsList(e);
[ e1, e2, e3, e4, e5, e6, e7, e8 ]
gap> One(O);
e8
gap> e[1]*e[2];
e4
gap> e[2]*e[1];
(-1)*e4
gap> Derivations(Basis(O)); SemiSimpleType(last);
<Lie algebra of dimension 14 over Rationals>
"G2"

# doc/ALCO.xml:133-146
gap> a := BasisVectors(Basis(OctavianIntegers));;
gap> for x in a do Display(x); od;
(-1/2)*e1+(1/2)*e5+(1/2)*e6+(1/2)*e7
(-1/2)*e1+(-1/2)*e2+(-1/2)*e4+(-1/2)*e7
(1/2)*e2+(1/2)*e3+(-1/2)*e5+(-1/2)*e7
(1/2)*e1+(-1/2)*e3+(1/2)*e4+(1/2)*e5
(-1/2)*e2+(1/2)*e3+(-1/2)*e5+(1/2)*e7
(1/2)*e2+(-1/2)*e4+(1/2)*e5+(-1/2)*e6
(-1/2)*e1+(-1/2)*e3+(1/2)*e4+(-1/2)*e5
(1/2)*e1+(-1/2)*e4+(1/2)*e6+(-1/2)*e8
gap> ForAll(a, IsOctavianInt);
true
gap> ForAll(a/2, IsOctavianInt);
false

# doc/ALCO.xml:154-160
gap> BasisVectors(OctonionE8Basis) = BasisVectors(Basis(OctavianIntegers));
true
gap> g := List(OctonionE8Basis, x -> 
> List(OctonionE8Basis, y -> 
> Norm(x+y) - Norm(x) - Norm(y)));;
gap> IsGossetLatticeGramMatrix(g);
true

# doc/ALCO.xml:192-197
gap> Oct := OctonionAlgebra(Rationals);;
gap> List(Basis(Oct), Norm);
[ 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> x := Random(Oct);; y := Random(Oct);;
gap> Norm(x*y) = Norm(x)*Norm(y);
true

# doc/ALCO.xml:205-210
gap> e := BasisVectors(Basis(OctonionAlgebra(Rationals)));
[ e1, e2, e3, e4, e5, e6, e7, e8 ]
gap> List(e, Trace);
[ 0, 0, 0, 0, 0, 0, 0, 2 ]
gap> List(e, RealPart);
[ 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, e8 ]

# doc/ALCO.xml:245-248
gap> e := BasisVectors(Basis(OctonionAlgebra(Rationals)));
[ e1, e2, e3, e4, e5, e6, e7, e8 ]
gap> List(e, ComplexConjugate);
[ (-1)*e1, (-1)*e2, (-1)*e3, (-1)*e4, (-1)*e5, (-1)*e6, (-1)*e7, e8 ]

# doc/ALCO.xml:255-258
gap> e := BasisVectors(Basis(OctonionAlgebra(Rationals)));
[ e1, e2, e3, e4, e5, e6, e7, e8 ]
gap> List(e, RealPart);
[ 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, e8 ]

# doc/ALCO.xml:276-280
gap> e := 2*BasisVectors(OctonionE8Basis);;
gap> e{[1,2]};
[ (-1)*e1+e5+e6+e7, (-1)*e1+(-1)*e2+(-1)*e4+(-1)*e7 ]
gap> OctonionToRealVector(OctonionE8Basis, e{[1,2]});
[ 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0 ]

# doc/ALCO.xml:287-290
gap> RealToOctonionVector(Basis(OctonionAlgebra(Rationals)), [1..16]);;
gap> for x in last do Display(x); od;
e1+(2)*e2+(3)*e3+(4)*e4+(5)*e5+(6)*e6+(7)*e7+(8)*e8
(9)*e1+(10)*e2+(11)*e3+(12)*e4+(13)*e5+(14)*e6+(15)*e7+(16)*e8

# doc/ALCO.xml:298-306
gap> Oct := OctonionAlgebra(Rationals);;
gap> x := [One(Oct), Basis(Oct)[1], Basis(Oct)[2]];
[ e8, e1, e2 ]
gap> y := VectorToIdempotentMatrix(x);; Display(y);
[ [   (1/3)*e8,   (1/3)*e1,   (1/3)*e2 ],
  [  (-1/3)*e1,   (1/3)*e8,  (-1/3)*e4 ],
  [  (-1/3)*e2,   (1/3)*e4,   (1/3)*e8 ] ]
gap> IsIdempotent(y);
true

# doc/ALCO.xml:315-316
gap> WeylReflection([1,0,1],[0,1,1]);
[ -1, 1, 0 ]

# doc/ALCO.xml:328-335
gap> H := QuaternionAlgebra(Rationals); AsList(Basis(H));
<algebra-with-one of dimension 4 over Rationals>
[ e, i, j, k ]
gap> List(Basis(H), Norm);
[ 1, 1, 1, 1 ]
gap> x := Random(H);; y := Random(H);;
gap> Norm(x*y) = Norm(x)*Norm(y);
true

# doc/ALCO.xml:341-344
gap> e := BasisVectors(Basis(QuaternionAlgebra(Rationals)));
[ e, i, j, k ]
gap> List(e, Trace);
[ 2, 0, 0, 0 ]

# doc/ALCO.xml:351-354
gap> e := BasisVectors(Basis(QuaternionAlgebra(Rationals)));
[ e, i, j, k ]
gap> List(e, ComplexConjugate);
[ e, (-1)*i, (-1)*j, (-1)*k ]

# doc/ALCO.xml:361-369
gap> H := QuaternionAlgebra(Rationals); AsList(Basis(H));
<algebra-with-one of dimension 4 over Rationals>
[ e, i, j, k ]
gap> List(Basis(H), ComplexConjugate);
[ e, (-1)*i, (-1)*j, (-1)*k ]
gap> List(Basis(H), RealPart);
[ e, 0*e, 0*e, 0*e ]
gap> List(Basis(H), ImaginaryPart);
[ 0*e, e, k, (-1)*j ]

# doc/ALCO.xml:397-406
gap> f := BasisVectors(Basis(HurwitzIntegers));;
gap> for x in f do Display(x); od;
(-1/2)*e+(-1/2)*i+(-1/2)*j+(1/2)*k
(-1/2)*e+(-1/2)*i+(1/2)*j+(-1/2)*k
(-1/2)*e+(1/2)*i+(-1/2)*j+(-1/2)*k
e
gap> ForAll(f, IsHurwitzInt);
true
gap> ForAll(f/2, IsHurwitzInt);
false

# doc/ALCO.xml:415-420
gap> B := QuaternionD4Basis;;
gap> for x in BasisVectors(B) do Display(x); od;
(-1/2)*e+(-1/2)*i+(-1/2)*j+(1/2)*k
(-1/2)*e+(-1/2)*i+(1/2)*j+(-1/2)*k
(-1/2)*e+(1/2)*i+(-1/2)*j+(-1/2)*k
e

# doc/ALCO.xml:449-455
gap> sigma := (1-Sqrt(5))/2;; tau := (1+Sqrt(5))/2;;
gap> x := 5 + 3*sigma;; GoldenModSigma(x);
5
gap> GoldenModSigma(sigma);
0
gap> GoldenModSigma(tau);
1

# doc/ALCO.xml:463-476
gap> f := BasisVectors(Basis(IcosianRing));;
gap> for x in f do Display(x); od;
(-1)*i
(-1/2*E(5)^2-1/2*E(5)^3)*i+(1/2)*j+(-1/2*E(5)-1/2*E(5)^4)*k
(-1)*j
(-1/2*E(5)-1/2*E(5)^4)*e+(1/2)*j+(-1/2*E(5)^2-1/2*E(5)^3)*k
gap> ForAll(f, IsIcosian);
true
gap> ForAll(f/2, IsIcosian);
false
gap> EB(5) = -(1/2)*(1-Sqrt(5));
true
gap> ForAll(f*EB(5), IsIcosian);
true

# doc/ALCO.xml:483-488
gap> B := IcosianH4Basis;;
gap> for x in BasisVectors(B) do Display(x); od;
(-1)*i
(-1/2*E(5)^2-1/2*E(5)^3)*i+(1/2)*j+(-1/2*E(5)-1/2*E(5)^4)*k
(-1)*j
(-1/2*E(5)-1/2*E(5)^4)*e+(1/2)*j+(-1/2*E(5)^2-1/2*E(5)^3)*k

# doc/ALCO.xml:502-507
gap> f := BasisVectors(Basis(EisensteinIntegers));
[ 1, E(3) ]
gap> IsEisenInt(E(4));
false
gap> IsEisenInt(1+E(3)^2);
true

# doc/ALCO.xml:516-521
gap> f := BasisVectors(Basis(KleinianIntegers));
[ 1, E(7)+E(7)^2+E(7)^4 ]
gap> IsKleinInt(E(4));
false
gap> IsKleinInt(1+E(7)+E(7)^2+E(7)^4);
true

#
gap> STOP_TEST("alco02.tst", 1);
