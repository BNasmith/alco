# ALCO, chapter 2
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("alco02.tst");

# doc/ALCO.xml:111-125
gap> O := OctonionAlgebra(Rationals); e := Basis(O);;
<algebra-with-one of dimension 8 over Rationals>
gap> LeftActingDomain(O);
Rationals
gap> AsList(e);
[ e1, e2, e3, e4, e5, e6, e7, e8 ]
gap> One(O);
e8
gap> e[1]*e[2];
e4
gap> e[2]*e[1];
(-1)*e4
gap> Derivations(Basis(O)); SemiSimpleType(last);
<Lie algebra of dimension 14 over Rationals>
"G2"

# doc/ALCO.xml:133-146
gap> a := BasisVectors(Basis(OctavianIntegers));;
gap> for x in a do Display(x); od;
(-1/2)*e1+(1/2)*e5+(1/2)*e6+(1/2)*e7
(-1/2)*e1+(-1/2)*e2+(-1/2)*e4+(-1/2)*e7
(1/2)*e2+(1/2)*e3+(-1/2)*e5+(-1/2)*e7
(1/2)*e1+(-1/2)*e3+(1/2)*e4+(1/2)*e5
(-1/2)*e2+(1/2)*e3+(-1/2)*e5+(1/2)*e7
(1/2)*e2+(-1/2)*e4+(1/2)*e5+(-1/2)*e6
(-1/2)*e1+(-1/2)*e3+(1/2)*e4+(-1/2)*e5
(1/2)*e1+(-1/2)*e4+(1/2)*e6+(-1/2)*e8
gap> ForAll(a, IsOctavianInt);
true
gap> ForAll(a/2, IsOctavianInt);
false

# doc/ALCO.xml:154-155
gap> BasisVectors(OctonionE8Basis) = BasisVectors(Basis(OctavianIntegers));
true

# doc/ALCO.xml:187-192
gap> Oct := OctonionAlgebra(Rationals);;
gap> List(Basis(Oct), Norm);
[ 1, 1, 1, 1, 1, 1, 1, 1 ]
gap> x := Random(Oct);; y := Random(Oct);;
gap> Norm(x*y) = Norm(x)*Norm(y);
true

# doc/ALCO.xml:200-203
gap> List(Basis(OctonionAlgebra(Rationals)), Trace);
[ 0, 0, 0, 0, 0, 0, 0, 2 ]
gap> List(Basis(OctonionAlgebra(Rationals)), RealPart);
[ 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, 0*e1, e8 ]

# doc/ALCO.xml:261-265
gap> e := 2*BasisVectors(OctonionE8Basis);;
gap> e{[1,2]};
[ (-1)*e1+e5+e6+e7, (-1)*e1+(-1)*e2+(-1)*e4+(-1)*e7 ]
gap> OctonionToRealVector(OctonionE8Basis, e{[1,2]});
[ 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0 ]

# doc/ALCO.xml:272-275
gap> RealToOctonionVector(Basis(OctonionAlgebra(Rationals)), [1..16]);;
gap> for x in last do Display(x); od;
e1+(2)*e2+(3)*e3+(4)*e4+(5)*e5+(6)*e6+(7)*e7+(8)*e8
(9)*e1+(10)*e2+(11)*e3+(12)*e4+(13)*e5+(14)*e6+(15)*e7+(16)*e8

# doc/ALCO.xml:283-291
gap> Oct := OctonionAlgebra(Rationals);;
gap> x := [One(Oct), Basis(Oct)[1], Basis(Oct)[2]];
[ e8, e1, e2 ]
gap> y := VectorToIdempotentMatrix(x);; Display(y);
[ [   (1/3)*e8,   (1/3)*e1,   (1/3)*e2 ],
  [  (-1/3)*e1,   (1/3)*e8,  (-1/3)*e4 ],
  [  (-1/3)*e2,   (1/3)*e4,   (1/3)*e8 ] ]
gap> IsIdempotent(y);
true

# doc/ALCO.xml:300-301
gap> WeylReflection([1,0,1],[0,1,1]);
[ -1, 1, 0 ]

# doc/ALCO.xml:313-320
gap> H := QuaternionAlgebra(Rationals); AsList(Basis(H));
<algebra-with-one of dimension 4 over Rationals>
[ e, i, j, k ]
gap> List(Basis(H), Norm);
[ 1, 1, 1, 1 ]
gap> x := Random(H);; y := Random(H);;
gap> Norm(x*y) = Norm(x)*Norm(y);
true

# doc/ALCO.xml:327-329
gap> H := QuaternionAlgebra(Rationals);;
gap> List(Basis(H), Trace);
[ 2, 0, 0, 0 ]

# doc/ALCO.xml:341-349
gap> H := QuaternionAlgebra(Rationals); AsList(Basis(H));
<algebra-with-one of dimension 4 over Rationals>
[ e, i, j, k ]
gap> List(Basis(H), ComplexConjugate);
[ e, (-1)*i, (-1)*j, (-1)*k ]
gap> List(Basis(H), RealPart);
[ e, 0*e, 0*e, 0*e ]
gap> List(Basis(H), ImaginaryPart);
[ 0*e, e, k, (-1)*j ]

# doc/ALCO.xml:378-383
gap> B := QuaternionD4Basis;;
gap> for x in BasisVectors(B) do Display(x); od;
(-1/2)*e+(-1/2)*i+(-1/2)*j+(1/2)*k
(-1/2)*e+(-1/2)*i+(1/2)*j+(-1/2)*k
(-1/2)*e+(1/2)*i+(-1/2)*j+(-1/2)*k
e

# doc/ALCO.xml:412-418
gap> sigma := (1-Sqrt(5))/2;; tau := (1+Sqrt(5))/2;;
gap> x := 5 + 3*sigma;; GoldenModSigma(x);
5
gap> GoldenModSigma(sigma);
0
gap> GoldenModSigma(tau);
1

# doc/ALCO.xml:426-431
gap> B := IcosianH4Basis;;
gap> for x in BasisVectors(B) do Display(x); od;
(-1)*i
(-1/2*E(5)^2-1/2*E(5)^3)*i+(1/2)*j+(-1/2*E(5)-1/2*E(5)^4)*k
(-1)*j
(-1/2*E(5)-1/2*E(5)^4)*e+(1/2)*j+(-1/2*E(5)^2-1/2*E(5)^3)*k

#
gap> STOP_TEST("alco02.tst", 1);
